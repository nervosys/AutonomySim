//! C/C++ FFI Bindings for AutonomySim
//!
//! This crate provides a C-compatible Foreign Function Interface (FFI) for
//! AutonomySim, enabling integration with C and C++ applications.
//!
//! # Architecture
//!
//! ```text
//! C/C++ Application
//!       ↓
//! autonomysim.h (generated by cbindgen)
//!       ↓
//! libautonomysim_bindings.so/.dll/.dylib
//!       ↓
//! Rust AutonomySim Core
//! ```
//!
//! # Features
//!
//! - **RF Propagation**: Calculate signal strength using various models
//! - **Gaussian Splatting**: Fast neural RF field queries
//! - **Antenna Patterns**: Isotropic, directional, dipole
//! - **Link Budget**: Complete RF link calculations
//! - **Memory Safe**: Proper ownership and cleanup
//!
//! # Example (C)
//!
//! ```c
//! #include "autonomysim.h"
//!
//! int main() {
//!     // Create transmitter and receiver positions
//!     AutonomySimVec3 tx = {0.0, 0.0, 10.0};
//!     AutonomySimVec3 rx = {100.0, 0.0, 2.0};
//!
//!     // Calculate free space path loss
//!     double frequency_hz = 2.4e9;  // 2.4 GHz
//!     double path_loss = autonomysim_free_space_path_loss(tx, rx, frequency_hz);
//!
//!     printf("Path loss: %.2f dB\n", path_loss);
//!
//!     return 0;
//! }
//! ```
//!
//! # Building
//!
//! ```bash
//! cargo build --release --package autonomysim-bindings
//! ```
//!
//! The C header will be generated at `include/autonomysim.h`.

use autonomysim_gaussian_splat::{
    GaussianRFField, RFMeasurement, TrainingConfig as GaussianTrainingConfig,
};
use autonomysim_rf_core::{
    antenna::{Antenna, AntennaPattern},
    utils::{dbm_to_watts, friis_path_loss, link_budget, watts_to_dbm, wavelength},
};
use nalgebra::Vector3;
use std::ffi::{c_char, CStr};
use std::ptr;
use std::slice;

// ============================================================================
// Type Definitions
// ============================================================================

/// 3D vector for positions and directions
///
/// Compatible with most C/C++ vector libraries.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AutonomySimVec3 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}

impl From<AutonomySimVec3> for Vector3<f64> {
    fn from(v: AutonomySimVec3) -> Self {
        Vector3::new(v.x, v.y, v.z)
    }
}

impl From<Vector3<f64>> for AutonomySimVec3 {
    fn from(v: Vector3<f64>) -> Self {
        Self {
            x: v.x,
            y: v.y,
            z: v.z,
        }
    }
}

/// RF measurement data point
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AutonomySimRFMeasurement {
    pub position: AutonomySimVec3,
    pub rssi_dbm: f64,
    pub weight: f64,
}

/// Configuration for Gaussian splatting training
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AutonomySimGaussianConfig {
    pub num_gaussians: usize,
    pub max_iterations: usize,
    pub convergence_threshold: f64,
    pub learning_rate: f64,
    pub initial_variance: f64,
    pub regularization: f64,
    pub parallel: bool,
}

impl From<AutonomySimGaussianConfig> for GaussianTrainingConfig {
    fn from(c: AutonomySimGaussianConfig) -> Self {
        Self {
            num_gaussians: c.num_gaussians,
            max_iterations: c.max_iterations,
            convergence_threshold: c.convergence_threshold,
            learning_rate: c.learning_rate,
            initial_variance: c.initial_variance,
            regularization: c.regularization,
            parallel: c.parallel,
        }
    }
}

/// Opaque handle to Gaussian RF field
///
/// Must be freed with `autonomysim_gaussian_field_free()`
#[repr(C)]
pub struct AutonomySimGaussianField {
    _private: [u8; 0],
}

/// Result codes for C API
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum AutonomySimResult {
    /// Operation succeeded
    Ok = 0,
    /// Null pointer passed
    NullPointer = 1,
    /// Invalid parameter
    InvalidParameter = 2,
    /// Training failed
    TrainingFailed = 3,
    /// Query failed
    QueryFailed = 4,
    /// Memory allocation failed
    OutOfMemory = 5,
}

// ============================================================================
// Internal Helper Functions
// ============================================================================

/// Internal: Log-distance path loss calculation
fn log_distance_path_loss_internal(
    distance: f64,
    frequency_hz: f64,
    path_loss_exponent: f64,
    reference_distance: f64,
) -> f64 {
    let pl0 = friis_path_loss(reference_distance, frequency_hz);
    pl0 + 10.0 * path_loss_exponent * (distance / reference_distance).log10()
}

/// Internal: Two-ray ground reflection model
fn two_ray_ground_reflection_internal(
    distance: f64,
    tx_height: f64,
    rx_height: f64,
    frequency_hz: f64,
) -> f64 {
    if distance < 1.0 {
        return friis_path_loss(distance, frequency_hz);
    }

    // Simplified two-ray model
    40.0 * distance.log10() - (10.0 * tx_height.log10() + 10.0 * rx_height.log10())
}

// ============================================================================
// RF Propagation Functions
// ============================================================================

/// Calculate free space path loss (Friis equation)
///
/// # Arguments
///
/// * `tx` - Transmitter position (meters)
/// * `rx` - Receiver position (meters)
/// * `frequency_hz` - Frequency in Hz
///
/// # Returns
///
/// Path loss in dB
///
/// # Safety
///
/// This function is safe to call from C.
#[no_mangle]
pub extern "C" fn autonomysim_free_space_path_loss(
    tx: AutonomySimVec3,
    rx: AutonomySimVec3,
    frequency_hz: f64,
) -> f64 {
    let distance = (Vector3::from(tx) - Vector3::from(rx)).norm();
    friis_path_loss(distance, frequency_hz)
}

/// Calculate log-distance path loss
///
/// # Arguments
///
/// * `tx` - Transmitter position (meters)
/// * `rx` - Receiver position (meters)
/// * `frequency_hz` - Frequency in Hz
/// * `path_loss_exponent` - Path loss exponent (typically 2-4)
/// * `reference_distance` - Reference distance in meters (typically 1.0)
///
/// # Returns
///
/// Path loss in dB
#[no_mangle]
pub extern "C" fn autonomysim_log_distance_path_loss(
    tx: AutonomySimVec3,
    rx: AutonomySimVec3,
    frequency_hz: f64,
    path_loss_exponent: f64,
    reference_distance: f64,
) -> f64 {
    let distance = (Vector3::from(tx) - Vector3::from(rx)).norm();
    log_distance_path_loss_internal(
        distance,
        frequency_hz,
        path_loss_exponent,
        reference_distance,
    )
}

/// Calculate two-ray ground reflection path loss
///
/// # Arguments
///
/// * `tx` - Transmitter position (meters)
/// * `rx` - Receiver position (meters)
/// * `frequency_hz` - Frequency in Hz
///
/// # Returns
///
/// Path loss in dB including ground reflection
#[no_mangle]
pub extern "C" fn autonomysim_two_ray_ground_reflection(
    tx: AutonomySimVec3,
    rx: AutonomySimVec3,
    frequency_hz: f64,
) -> f64 {
    let tx_vec = Vector3::from(tx);
    let rx_vec = Vector3::from(rx);
    let distance = (tx_vec - rx_vec).norm();
    two_ray_ground_reflection_internal(distance, tx_vec.z, rx_vec.z, frequency_hz)
}

/// Calculate link budget
///
/// # Arguments
///
/// * `tx_power_dbm` - Transmitter power in dBm
/// * `tx_gain_db` - Transmitter antenna gain in dB
/// * `rx_gain_db` - Receiver antenna gain in dB
/// * `path_loss_db` - Path loss in dB
/// * `additional_losses_db` - Additional losses (cable, etc.) in dB
///
/// # Returns
///
/// Received signal strength in dBm
#[no_mangle]
pub extern "C" fn autonomysim_link_budget(
    tx_power_dbm: f64,
    tx_gain_db: f64,
    rx_gain_db: f64,
    path_loss_db: f64,
    additional_losses_db: f64,
) -> f64 {
    link_budget(
        tx_power_dbm,
        tx_gain_db,
        rx_gain_db,
        path_loss_db,
        additional_losses_db,
    )
}

/// Calculate wavelength from frequency
///
/// # Arguments
///
/// * `frequency_hz` - Frequency in Hz
///
/// # Returns
///
/// Wavelength in meters
#[no_mangle]
pub extern "C" fn autonomysim_wavelength(frequency_hz: f64) -> f64 {
    wavelength(frequency_hz)
}

/// Convert dBm to watts
///
/// # Arguments
///
/// * `dbm` - Power in dBm
///
/// # Returns
///
/// Power in watts
#[no_mangle]
pub extern "C" fn autonomysim_dbm_to_watts(dbm: f64) -> f64 {
    dbm_to_watts(dbm)
}

/// Convert watts to dBm
///
/// # Arguments
///
/// * `watts` - Power in watts
///
/// # Returns
///
/// Power in dBm
#[no_mangle]
pub extern "C" fn autonomysim_watts_to_dbm(watts: f64) -> f64 {
    watts_to_dbm(watts)
}

// ============================================================================
// Antenna Pattern Functions
// ============================================================================

/// Calculate isotropic antenna gain (always 0 dB)
///
/// # Returns
///
/// Antenna gain in dBi (0.0)
#[no_mangle]
pub extern "C" fn autonomysim_isotropic_antenna_gain() -> f64 {
    let antenna = Antenna::isotropic();
    antenna.gain_dbi
}

/// Calculate directional antenna gain
///
/// # Arguments
///
/// * `direction` - Direction vector (will be normalized)
/// * `boresight` - Antenna boresight direction (will be normalized)
/// * `peak_gain_dbi` - Peak gain in dBi (unused - uses default 10 dBi)
/// * `beamwidth_degrees` - 3dB beamwidth in degrees (used for both az/el)
///
/// # Returns
///
/// Antenna gain in dBi (includes pattern loss)
#[no_mangle]
pub extern "C" fn autonomysim_directional_antenna_gain(
    direction: AutonomySimVec3,
    boresight: AutonomySimVec3,
    _peak_gain_dbi: f64,
    beamwidth_degrees: f64,
) -> f64 {
    let mut antenna = Antenna::directional(beamwidth_degrees, beamwidth_degrees);
    antenna.direction = Vector3::from(boresight).normalize();
    antenna.effective_gain(Vector3::from(direction))
}

/// Calculate dipole antenna gain
///
/// # Arguments
///
/// * `direction` - Direction vector (will be normalized)
/// * `dipole_axis` - Dipole axis direction (will be normalized)
///
/// # Returns
///
/// Antenna gain in dBi (includes pattern)
#[no_mangle]
pub extern "C" fn autonomysim_dipole_antenna_gain(
    direction: AutonomySimVec3,
    dipole_axis: AutonomySimVec3,
) -> f64 {
    let mut antenna = Antenna::dipole();
    antenna.direction = Vector3::from(dipole_axis).normalize();
    antenna.effective_gain(Vector3::from(direction))
}

// ============================================================================
// Gaussian Splatting Functions
// ============================================================================

/// Create default Gaussian training configuration
///
/// # Returns
///
/// Default configuration structure
#[no_mangle]
pub extern "C" fn autonomysim_gaussian_config_default() -> AutonomySimGaussianConfig {
    let config = GaussianTrainingConfig::default();
    AutonomySimGaussianConfig {
        num_gaussians: config.num_gaussians,
        max_iterations: config.max_iterations,
        convergence_threshold: config.convergence_threshold,
        learning_rate: config.learning_rate,
        initial_variance: config.initial_variance,
        regularization: config.regularization,
        parallel: config.parallel,
    }
}

/// Train a Gaussian RF field from measurements
///
/// # Arguments
///
/// * `measurements` - Array of RF measurements
/// * `num_measurements` - Number of measurements in array
/// * `config` - Training configuration
/// * `out_field` - Output pointer for trained field (must be freed)
///
/// # Returns
///
/// Result code
///
/// # Safety
///
/// - `measurements` must point to valid array of size `num_measurements`
/// - `out_field` must be a valid pointer
/// - Returned field must be freed with `autonomysim_gaussian_field_free()`
#[no_mangle]
pub unsafe extern "C" fn autonomysim_gaussian_field_train(
    measurements: *const AutonomySimRFMeasurement,
    num_measurements: usize,
    config: AutonomySimGaussianConfig,
    out_field: *mut *mut AutonomySimGaussianField,
) -> AutonomySimResult {
    if measurements.is_null() || out_field.is_null() {
        return AutonomySimResult::NullPointer;
    }

    if num_measurements == 0 {
        return AutonomySimResult::InvalidParameter;
    }

    // Convert measurements
    let measurements_slice = slice::from_raw_parts(measurements, num_measurements);
    let rust_measurements: Vec<RFMeasurement> = measurements_slice
        .iter()
        .map(|m| RFMeasurement {
            position: Vector3::from(m.position),
            rssi_dbm: m.rssi_dbm,
            weight: m.weight,
        })
        .collect();

    // Create and train field
    let mut field = GaussianRFField::new();
    match field.train(&rust_measurements, config.into()) {
        Ok(_) => {
            let boxed_field = Box::new(field);
            *out_field = Box::into_raw(boxed_field) as *mut AutonomySimGaussianField;
            AutonomySimResult::Ok
        }
        Err(_) => AutonomySimResult::TrainingFailed,
    }
}

/// Query signal strength at a position
///
/// # Arguments
///
/// * `field` - Trained Gaussian field
/// * `position` - Query position
/// * `out_rssi` - Output pointer for RSSI in dBm
///
/// # Returns
///
/// Result code
///
/// # Safety
///
/// - `field` must be a valid field returned from training
/// - `out_rssi` must be a valid pointer
#[no_mangle]
pub unsafe extern "C" fn autonomysim_gaussian_field_query(
    field: *const AutonomySimGaussianField,
    position: AutonomySimVec3,
    out_rssi: *mut f64,
) -> AutonomySimResult {
    if field.is_null() || out_rssi.is_null() {
        return AutonomySimResult::NullPointer;
    }

    let field = &*(field as *const GaussianRFField);
    let rssi = field.query(Vector3::from(position));
    *out_rssi = rssi;
    AutonomySimResult::Ok
}

/// Query signal strength at multiple positions (batch)
///
/// # Arguments
///
/// * `field` - Trained Gaussian field
/// * `positions` - Array of query positions
/// * `num_positions` - Number of positions
/// * `out_rssi` - Output array for RSSI values (must be pre-allocated)
///
/// # Returns
///
/// Result code
///
/// # Safety
///
/// - `field` must be a valid field
/// - `positions` must point to valid array of size `num_positions`
/// - `out_rssi` must point to valid array of size `num_positions`
#[no_mangle]
pub unsafe extern "C" fn autonomysim_gaussian_field_query_batch(
    field: *const AutonomySimGaussianField,
    positions: *const AutonomySimVec3,
    num_positions: usize,
    out_rssi: *mut f64,
) -> AutonomySimResult {
    if field.is_null() || positions.is_null() || out_rssi.is_null() {
        return AutonomySimResult::NullPointer;
    }

    if num_positions == 0 {
        return AutonomySimResult::InvalidParameter;
    }

    let field = &*(field as *const GaussianRFField);
    let positions_slice = slice::from_raw_parts(positions, num_positions);
    let rust_positions: Vec<Vector3<f64>> =
        positions_slice.iter().map(|p| Vector3::from(*p)).collect();

    let results = field.query_batch(&rust_positions);
    let out_slice = slice::from_raw_parts_mut(out_rssi, num_positions);
    out_slice.copy_from_slice(&results);

    AutonomySimResult::Ok
}

/// Get number of Gaussians in the field
///
/// # Arguments
///
/// * `field` - Trained Gaussian field
/// * `out_count` - Output pointer for count
///
/// # Returns
///
/// Result code
///
/// # Safety
///
/// - `field` must be a valid field
/// - `out_count` must be a valid pointer
#[no_mangle]
pub unsafe extern "C" fn autonomysim_gaussian_field_num_gaussians(
    field: *const AutonomySimGaussianField,
    out_count: *mut usize,
) -> AutonomySimResult {
    if field.is_null() || out_count.is_null() {
        return AutonomySimResult::NullPointer;
    }

    let field = &*(field as *const GaussianRFField);
    *out_count = field.gaussians.len();
    AutonomySimResult::Ok
}

/// Free a Gaussian RF field
///
/// # Arguments
///
/// * `field` - Field to free (can be null)
///
/// # Safety
///
/// - `field` must be null or a valid field returned from training
/// - After calling, `field` pointer is invalid
#[no_mangle]
pub unsafe extern "C" fn autonomysim_gaussian_field_free(field: *mut AutonomySimGaussianField) {
    if !field.is_null() {
        let _ = Box::from_raw(field as *mut GaussianRFField);
    }
}

// ============================================================================
// Version Information
// ============================================================================

/// Get AutonomySim version string
///
/// # Returns
///
/// Null-terminated version string (valid for program lifetime)
///
/// # Safety
///
/// Returned pointer is valid for the lifetime of the program.
#[no_mangle]
pub extern "C" fn autonomysim_version() -> *const c_char {
    concat!(env!("CARGO_PKG_VERSION"), "\0").as_ptr() as *const c_char
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vec3_conversion() {
        let c_vec = AutonomySimVec3 {
            x: 1.0,
            y: 2.0,
            z: 3.0,
        };
        let rust_vec: Vector3<f64> = c_vec.into();
        assert_eq!(rust_vec.x, 1.0);
        assert_eq!(rust_vec.y, 2.0);
        assert_eq!(rust_vec.z, 3.0);

        let c_vec2: AutonomySimVec3 = rust_vec.into();
        assert_eq!(c_vec2.x, 1.0);
        assert_eq!(c_vec2.y, 2.0);
        assert_eq!(c_vec2.z, 3.0);
    }

    #[test]
    fn test_free_space_path_loss() {
        let tx = AutonomySimVec3 {
            x: 0.0,
            y: 0.0,
            z: 10.0,
        };
        let rx = AutonomySimVec3 {
            x: 100.0,
            y: 0.0,
            z: 2.0,
        };
        let frequency_hz = 2.4e9;

        let path_loss = autonomysim_free_space_path_loss(tx, rx, frequency_hz);
        assert!(path_loss > 0.0);
        assert!(path_loss < 200.0); // Reasonable range
    }

    #[test]
    fn test_link_budget() {
        let tx_power = 20.0; // 20 dBm
        let tx_gain = 3.0; // 3 dBi
        let rx_gain = 3.0; // 3 dBi
        let path_loss = 100.0; // 100 dB
        let additional = 5.0; // 5 dB

        let rssi = autonomysim_link_budget(tx_power, tx_gain, rx_gain, path_loss, additional);
        assert_eq!(rssi, 20.0 + 3.0 + 3.0 - 100.0 - 5.0);
    }

    #[test]
    fn test_power_conversions() {
        let dbm = 30.0;
        let watts = autonomysim_dbm_to_watts(dbm);
        let dbm2 = autonomysim_watts_to_dbm(watts);
        assert!((dbm - dbm2).abs() < 1e-10);
    }

    #[test]
    fn test_isotropic_antenna() {
        let gain = autonomysim_isotropic_antenna_gain();
        assert_eq!(gain, 0.0);
    }

    #[test]
    fn test_gaussian_config_default() {
        let config = autonomysim_gaussian_config_default();
        assert_eq!(config.num_gaussians, 100);
        assert_eq!(config.max_iterations, 1000);
        assert!(config.parallel);
    }

    #[test]
    fn test_gaussian_field_lifecycle() {
        unsafe {
            // Create measurements
            let measurements = vec![
                AutonomySimRFMeasurement {
                    position: AutonomySimVec3 {
                        x: 10.0,
                        y: 20.0,
                        z: 5.0,
                    },
                    rssi_dbm: -65.0,
                    weight: 1.0,
                },
                AutonomySimRFMeasurement {
                    position: AutonomySimVec3 {
                        x: 15.0,
                        y: 25.0,
                        z: 5.0,
                    },
                    rssi_dbm: -70.0,
                    weight: 1.0,
                },
            ];

            let mut config = autonomysim_gaussian_config_default();
            config.num_gaussians = 2;
            config.max_iterations = 10;

            let mut field: *mut AutonomySimGaussianField = ptr::null_mut();
            let result = autonomysim_gaussian_field_train(
                measurements.as_ptr(),
                measurements.len(),
                config,
                &mut field,
            );

            assert_eq!(result, AutonomySimResult::Ok);
            assert!(!field.is_null());

            // Query
            let query_pos = AutonomySimVec3 {
                x: 12.0,
                y: 22.0,
                z: 5.0,
            };
            let mut rssi = 0.0;
            let query_result = autonomysim_gaussian_field_query(field, query_pos, &mut rssi);
            assert_eq!(query_result, AutonomySimResult::Ok);
            assert!(rssi < 0.0); // Should be negative dBm

            // Get count
            let mut count = 0;
            let count_result = autonomysim_gaussian_field_num_gaussians(field, &mut count);
            assert_eq!(count_result, AutonomySimResult::Ok);
            assert_eq!(count, 2);

            // Free
            autonomysim_gaussian_field_free(field);
        }
    }

    #[test]
    fn test_version() {
        let version_ptr = autonomysim_version();
        assert!(!version_ptr.is_null());
        unsafe {
            let version = CStr::from_ptr(version_ptr).to_str().unwrap();
            assert!(!version.is_empty());
            assert!(version.contains('.'));
        }
    }
}
